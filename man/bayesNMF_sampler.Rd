% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bayesNMF_sampler.R
\name{bayesNMF_sampler}
\alias{bayesNMF_sampler}
\title{bayesNMF_sampler R6 class}
\description{
bayesNMF_sampler R6 class

bayesNMF_sampler R6 class
}
\details{
This class implements the Gibbs sampler for Bayesian Nonnegative Matrix Factorization with automatically learned rank and optional Metropolis-Hastings updates for computational efficiency.
It holds the data, model specifications, current sampler state, sampler history, inference results, and various utility functions for visualization and postprocessing.
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{data}}{matrix, observed data (rows are variables, columns are samples)}

\item{\code{dims}}{list, dimensions of the data (K is variables, N is latent dimension, G is samples)}

\item{\code{specs}}{list, model specifications (rank, likelihood, prior, MH, learning_rank, convergence_control, output_dir, overwrite, verbosity, periodic_save, save_all_samples)}

\item{\code{temperature_schedule}}{vector, temperature schedule (temperature_schedule\link{i} is the temperature for iteration i)}

\item{\code{hyperprior_params}}{list, fixed hyperprior parameters}

\item{\code{prior_params}}{list, current values of prior parameters}

\item{\code{params}}{list, current values of parameters}

\item{\code{samples}}{list, sampler history (samples[\link{name}][\link{iter}] is the value of parameter name at iteration iter)}

\item{\code{acceptance_rates}}{list, acceptance rates for Metropolis-Hastings updates (all 1 if MH is FALSE)}

\item{\code{state}}{list, current sampler state (iter is the current iteration, indent is the current indentation level, converged is whether the sampler has converged)}

\item{\code{MAP}}{list, current maximum a posteriori (MAP) estimate from most recent convergence check}

\item{\code{credible_intervals}}{list, 95\% credible intervals for the current MAP estimates (credible_intervals[\link{name}][\link{"lower"}] and credible_intervals[\link{name}][\link{"upper"}] are the bounds for parameter name)}

\item{\code{reference_comparison}}{list, includes assignments, votes, and plots for a given reference set}

\item{\code{time}}{list, time taken for various operations (total is the total time taken, per_iter is the average time per iteration)}

\item{\code{log_con}}{file, connection to log file}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-bayesNMF_sampler-new}{\code{bayesNMF_sampler$new()}}
\item \href{#method-bayesNMF_sampler-run_gibbs_sampler}{\code{bayesNMF_sampler$run_gibbs_sampler()}}
\item \href{#method-bayesNMF_sampler-save_object}{\code{bayesNMF_sampler$save_object()}}
\item \href{#method-bayesNMF_sampler-log}{\code{bayesNMF_sampler$log()}}
\item \href{#method-bayesNMF_sampler-get_Mhat}{\code{bayesNMF_sampler$get_Mhat()}}
\item \href{#method-bayesNMF_sampler-get_loglik}{\code{bayesNMF_sampler$get_loglik()}}
\item \href{#method-bayesNMF_sampler-get_logpost}{\code{bayesNMF_sampler$get_logpost()}}
\item \href{#method-bayesNMF_sampler-get_MAP}{\code{bayesNMF_sampler$get_MAP()}}
\item \href{#method-bayesNMF_sampler-assign_signatures_ensemble}{\code{bayesNMF_sampler$assign_signatures_ensemble()}}
\item \href{#method-bayesNMF_sampler-clone}{\code{bayesNMF_sampler$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-bayesNMF_sampler-new"></a>}}
\if{latex}{\out{\hypertarget{method-bayesNMF_sampler-new}{}}}
\subsection{Method \code{new()}}{
Initialize a bayesNMF_sampler object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{bayesNMF_sampler$new(
  data,
  rank,
  likelihood = "poisson",
  prior = "truncnormal",
  rank_method = "SBFI",
  MH = likelihood == "poisson" & prior \%in\% c("truncnormal", "exponential"),
  convergence_control = new_convergence_control(),
  prop_temp = 0.2,
  post_warmup = 2 * convergence_control$MAP_over,
  output_dir = paste0("nmf_", likelihood, "_", prior),
  overwrite = FALSE,
  hyperprior_params = list(),
  init_prior_params = list(),
  init_params = list(),
  verbosity = 1,
  periodic_save = TRUE,
  save_all_samples = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{data}}{matrix, observed data (rows are variables, columns are samples)}

\item{\code{rank}}{integer, number of signatures or range of ranks to consider (default 1:10)}

\item{\code{likelihood}}{string, likelihood distribution for M, one of "poisson", "normal" (default "poisson")}

\item{\code{prior}}{string, prior distribution for P and E, one of "truncnormal", "exponential", "gamma" (default "truncnormal")}

\item{\code{rank_method}}{string, method to determine rank, one of "SBFI", "BFI", "BIC" (heuristic) (default "SBFI")}

\item{\code{MH}}{boolean, if likelihood is Poisson and prior is "truncnormal" or "exponential", whether to use Metropolis-Hastings updates described in the paper (default TRUE when possible)}

\item{\code{convergence_control}}{list, convergence control parameters (see \code{new_convergence_control()} for default values)}

\item{\code{prop_temp}}{float, proportion of iterations to use for tempering if learning rank (default 0.2)}

\item{\code{post_warmup}}{integer, number of iterations post-warmup to sample from (if MH = TRUE) (default 2 * convergence_control$MAP_over)}

\item{\code{output_dir}}{string, output directory, will be created if it does not exist}

\item{\code{overwrite}}{boolean, whether to overwrite existing output, will delete existing output directory if it exists (default FALSE)}

\item{\code{hyperprior_params}}{list, fixed hyperprior parameters (will be filled with default values if not provided)}

\item{\code{init_prior_params}}{list, initial prior parameters (will be initialized from hyperpriors if not provided)}

\item{\code{init_params}}{list, initial parameters (will be initialized from priors if not provided)}

\item{\code{verbosity}}{integer, verbosity level (default 1)}

\item{\code{periodic_save}}{boolean, whether to save the sampler object periodically (default TRUE, set to FALSE to reduce I/O and computational time)}

\item{\code{save_all_samples}}{boolean, whether to save all samples (default TRUE, set to FALSE to reduce memory usage)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-bayesNMF_sampler-run_gibbs_sampler"></a>}}
\if{latex}{\out{\hypertarget{method-bayesNMF_sampler-run_gibbs_sampler}{}}}
\subsection{Method \code{run_gibbs_sampler()}}{
Perform Gibbs sampling
Samples until convergence or maxiters is reached, plus additional post_warmup samples after convergence if MH is TRUE
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{bayesNMF_sampler$run_gibbs_sampler()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-bayesNMF_sampler-save_object"></a>}}
\if{latex}{\out{\hypertarget{method-bayesNMF_sampler-save_object}{}}}
\subsection{Method \code{save_object()}}{
Save the sampler object to the output directory
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{bayesNMF_sampler$save_object()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
None, saves the sampler object to the output directory
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-bayesNMF_sampler-log"></a>}}
\if{latex}{\out{\hypertarget{method-bayesNMF_sampler-log}{}}}
\subsection{Method \code{log()}}{
Log a message to the log file
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{bayesNMF_sampler$log(msg, verbosity = 5)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{msg}}{string, message to log}

\item{\code{verbosity}}{integer, verbosity level (default 5, only logs messages with verbosity <= self$specs$verbosity)}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-bayesNMF_sampler-get_Mhat"></a>}}
\if{latex}{\out{\hypertarget{method-bayesNMF_sampler-get_Mhat}{}}}
\subsection{Method \code{get_Mhat()}}{
Compute the expected data matrix
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{bayesNMF_sampler$get_Mhat(P = NULL, A = NULL, E = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{P}}{matrix, optional, dimensions K x N, uses self$params$P if not provided}

\item{\code{A}}{matrix, optional, dimensions 1 x N, uses self$params$A if not provided}

\item{\code{E}}{matrix, optional, dimensions N x G, uses self$params$E if not provided}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
matrix, dimensions K x G
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-bayesNMF_sampler-get_loglik"></a>}}
\if{latex}{\out{\hypertarget{method-bayesNMF_sampler-get_loglik}{}}}
\subsection{Method \code{get_loglik()}}{
Compute the log likelihood
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{bayesNMF_sampler$get_loglik(
  P = NULL,
  A = NULL,
  E = NULL,
  sigmasq = NULL,
  likelihood = self$specs$likelihood,
  return_matrix = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{P}}{matrix, optional, dimensions K x N, uses self$params$P if not provided}

\item{\code{A}}{matrix, optional, dimensions 1 x N, uses self$params$A if not provided}

\item{\code{E}}{matrix, optional, dimensions N x G, uses self$params$E if not provided}

\item{\code{sigmasq}}{vector, optional, dimensions G, uses self$params$sigmasq if not provided, only used if likelihood is "normal"}

\item{\code{likelihood}}{string, likelihood distribution for M, one of "poisson", "normal", uses self$specs$likelihood if not provided}

\item{\code{return_matrix}}{boolean, whether to return the log likelihood matrix, used to compute acceptance ratios in MH updates (default FALSE)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
scalar log likelihood if return_matrix is FALSE, otherwise matrix of log likelihoods per observed value (K x G)
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-bayesNMF_sampler-get_logpost"></a>}}
\if{latex}{\out{\hypertarget{method-bayesNMF_sampler-get_logpost}{}}}
\subsection{Method \code{get_logpost()}}{
Compute the log posterior using model specifications
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{bayesNMF_sampler$get_logpost(P = NULL, A = NULL, E = NULL, sigmasq = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{P}}{matrix, optional, dimensions K x N, uses self$params$P if not provided}

\item{\code{A}}{matrix, optional, dimensions 1 x N, uses self$params$A if not provided}

\item{\code{E}}{matrix, optional, dimensions N x G, uses self$params$E if not provided}

\item{\code{sigmasq}}{vector, optional, dimensions G, uses self$params$sigmasq if not provided, only used if likelihood is "normal"}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
scalar log posterior
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-bayesNMF_sampler-get_MAP"></a>}}
\if{latex}{\out{\hypertarget{method-bayesNMF_sampler-get_MAP}{}}}
\subsection{Method \code{get_MAP()}}{
Compute the maximum a posteriori (MAP) estimate
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{bayesNMF_sampler$get_MAP(
  end_iter = self$state$iter,
  n_samples = self$specs$convergence_control$MAP_over,
  final = FALSE,
  credible_interval = 0.95
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{end_iter}}{integer, last iteration to consider for inference, defaults to current iteration}

\item{\code{n_samples}}{integer, number of samples to consider for inference, defaults to MAP_over specified in convergence control}

\item{\code{final}}{boolean, if TRUE, subset to only included signatures}

\item{\code{credible_interval}}{float, credible interval width (default 0.95)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
None, updates self$MAP and self$credible_intervals
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-bayesNMF_sampler-assign_signatures_ensemble"></a>}}
\if{latex}{\out{\hypertarget{method-bayesNMF_sampler-assign_signatures_ensemble}{}}}
\subsection{Method \code{assign_signatures_ensemble()}}{
Assign signatures for each posterior sample based on cosine similarity and ensemble with majority vote
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{bayesNMF_sampler$assign_signatures_ensemble(
  reference_P = "cosmic",
  idxs = self$MAP$idx,
  credible_interval = 0.95
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{reference_P}}{matrix, "cosmic", or NULL, reference signatures to align to}

\item{\code{idxs}}{vector of indices to consider (default "MAP_idx" indicates indices used to compute most recent MAP)}

\item{\code{credible_interval}}{numeric, credible interval to compute for cosine similarities (default 0.95)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
list of two data frames:
\itemize{
\item assignments: holds final assignments for each signature, cosine similarities between MAP estimates and reference signatures, and 95\% credible intervals for the cosine similarities.
\item votes: holds the proportion of votes for each signature assignment for each posterior sample. This includes signatures that did not receive majority vote, allowing users to understand posterior uncertainty in assignment.
}
and stores the result in self$reference_comparison
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-bayesNMF_sampler-clone"></a>}}
\if{latex}{\out{\hypertarget{method-bayesNMF_sampler-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{bayesNMF_sampler$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
